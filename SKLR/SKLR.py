import numpy as npimport timefrom sklearn.metrics.pairwise import pairwise_kernelsfrom .Sketches import SRHTfrom scipy.linalg import norm,inv__all__=["SKLR"]class SKLR(object):    def __init__(self,X,Y,sketch_dimension=0,lamda=1,kernel="rbf",method="srht"):                # X n*d data matrix        # Y n labels        assert X.shape[0]==Y.shape[0]                        self._kernel=kernel        self._method=method        self._X=X        self._Y=Y        self._lamda=lamda        self._dim=X.shape[1]        self._n=X.shape[0]        self._m=sketch_dimension        if self._m==0:            self._m=int(self._n**0.5)        self._alpha=np.zeros(self._m)        self._alphasave=np.ones(self._m)        self._precision=1e-5                        self.prediction=np.zeros(self._n)        self.loss=0        self.time=0                    @staticmethod    def kernel_matrix(X,kernel):        K=pairwise_kernels(X, metric=kernel)        return K        @staticmethod    def compute_SKs(K,method,n,m):        if method=="srht":            SketchSRHT=SRHT(n,m)            SK=SketchSRHT.Apply(K)            SKS=SketchSRHT.Apply(np.transpose(SK))                    return SK,SKS        @staticmethod    def compute_SKWKS(KS,n,m,W):        return ((KS[:,None].reshape(n,m,1)*KS[:,None])*W.reshape(n,1,1)).sum(axis=0)        @staticmethod    def sigmoid(X):                #print(X>10000)        return 1/(1+np.exp(-X))        @classmethod    def W(cls,SK,Y,alpha):        p=cls.sigmoid(Y* np.dot(alpha,SK))        W=p-p**2                return p,W                @classmethod    def cost(cls,KS, Y, alpha):        return -np.log(cls.sigmoid(Y.dot( np.dot(KS,alpha))) ).sum()                        def fit(self):                # fit kernel        self._K=self.kernel_matrix(self._X,self._kernel)        self._SK,self._SKS=self.compute_SKs(self._K,self._method,self._n,self._m)                        time_start=time.time()        while(norm(self._alphasave-self._alpha)>self._precision):            self._alphasave=(self._alpha).copy()            p,W=self.W(self._SK,self._Y,self._alpha)            SKWKS=self.compute_SKWKS(np.transpose(self._SK),self._n,self._m,W)                        inv_part=inv(SKWKS+self._lamda*self._SKS)            add_part=SKWKS.dot(self._alpha)+np.dot(self._SK,self._Y*(1-p))                        self._alpha=inv_part.dot(add_part)                        self.loss=self.cost(np.transpose(self._SK),self._Y,self._alpha)                    time_end=time.time()        self.time=time_end-time_start        self.prediction=(p>0.5)        self.probability=p        self.accuracy=(self.prediction==self._Y).sum()/self._n                                                