import numpy as npimport timefrom sklearn.metrics.pairwise import pairwise_kernelsfrom .Sketches import SRHTfrom .Sketching import SketchGaussianfrom scipy.linalg import norm,inv__all__=["DSKLR"]class DSKLR(object):    def __init__(self,X,Y,sketch_dimension=0,partition=16,kernel="rbf",method="gaussian"):                # X n*d data matrix        # Y n labels        assert X.shape[0]==Y.shape[0]                        self._kernel=kernel        self._method=method        self._X=X        self._Y=Y                self._dim=X.shape[1]        self._n=X.shape[0]        self._m=sketch_dimension        self._partition=partition        #self._lamda=int(0.5*(self._n/self._partition)**(-2/3))        self._lamda=1        if self._m==0:            #self._m=int(self._n**0.5)            self._m=int(np.sqrt(self._n/self._partition))        self._alpha=np.zeros((self._partition,self._m))                self._tilden=int(self._n/self._partition)                self._precision=1e-4                        #self.prediction=np.zeros(self._n)        self.loss=0        self.iteration=0        self._losssave=1e8        self.train_time=0                self.X_split=np.split(self._X,self._partition)        self.Y_split=np.split(self._Y,self._partition)                    @staticmethod    def kernel_matrix(X,kernel,X_test=None):        if X_test is not None:            K=pairwise_kernels(X,X_test, metric=kernel)        else:            K=pairwise_kernels(X, metric=kernel)                    return K        @staticmethod    def compute_SK(K,method,n,m,random_state=1):        if method=="srht":            SketchSRHT=SRHT(n,m,random_state=1)            SK=SketchSRHT.Apply(K)            #SKS=SketchSRHT.Apply(np.transpose(SK))        elif method=="gaussian":            SketchGAU=SketchGaussian(n,m,seed=random_state)            SK=SketchGAU.Apply(K)                                        return SK        @staticmethod    def compute_SKS(SK,method,n,m,random_state=1):        if method=="srht":            SketchSRHT=SRHT(n,m,random_state=1)            #SK=SketchSRHT.Apply(K)            SKS=SketchSRHT.Apply(np.transpose(SK))        elif method=="gaussian":            SketchGAU=SketchGaussian(n,m,seed=random_state)            #SK=SketchSRHT.Apply(K)            SKS=SketchGAU.Apply(np.transpose(SK))                    return SKS        @staticmethod    def compute_SKWKS(SKKS,n,W):        return (SKKS*W.reshape(n,1,1)).sum(axis=0)        @staticmethod    def sigmoid(X):                return .5 * (1 + np.tanh(.5 * X))                   @classmethod    def W(cls,SK,Y,alpha):        #print( np.matmul(alpha,SK))        p=cls.sigmoid( np.matmul(alpha,SK))        #sigma=cls.sigmoid( Y*np.matmul(alpha,SK))        W=p-p**2                return p,W                @classmethod    def cost(cls,KS, Y, alpha):        return -np.log(cls.sigmoid(Y*( np.matmul(KS,alpha)))+1e-8 ).sum()                def fit(self):                                for i in range(self._partition):            K=self.kernel_matrix(self.X_split[i],self._kernel)            SK=self.compute_SK(K,self._method,self._tilden,self._m)            SKS=self.compute_SKS(SK,self._method,self._tilden,self._m)            KS=np.transpose(SK)            SKKS=(KS[:,None].reshape(self._tilden,self._m,1)*KS[:,None])                                             alpha=np.random.normal(size=self._m)            while(abs(self._losssave-self.loss)>self._precision):                                                                               self._losssave=self.loss                                                                p,W=self.W(SK,self.Y_split[i],alpha)                                                                #print(p)                SKWKS=self.compute_SKWKS(SKKS,self._tilden,W)                                #print(SKWKS)                #print(SKS)                                inv_part=inv(SKWKS+self._lamda*SKS)                add_part=np.matmul(SKWKS,alpha)+np.matmul(SK,self.Y_split[i]*(1-p))                                                alpha=np.matmul(inv_part,add_part)                self.loss=self.cost(np.transpose(SK),self.Y_split[i],alpha)                                    self._losssave=1e8            self._alpha[i]=alpha                                                def predict(self,X_test):        time_start=time.time()        self._X_test=X_test        self.test_probability=np.zeros((self._partition,self._X_test.shape[0]))                for i in range(self._partition):                    K_test=self.kernel_matrix(self.X_split[i],self._kernel,self._X_test)            SK_test=self.compute_SK(K_test,self._method,self._tilden,self._m)                                            self.test_probability[i]=self.sigmoid(np.matmul(self._alpha[i],SK_test))                self.prediction=(self.test_probability.mean(axis=0)>0.5)*2-1                        #print(self.prediction)        time_end=time.time()        self.test_time=time_end-time_start                                                